///<reference path="../testReference.ts" />

describe("Scales", () => {
  describe("QuantitativeScale", () => {
    describe("computing extents", () => {
      const expectedMin = 1;
      const expectedMax = 11;
      const expectedExtent = [expectedMin, expectedMax];

      const testCases = [
        {
          description: "gives the minimum and maxiumum when the domain is numeric",
          values: [expectedMax, 3, 2, expectedMin]
        },
        // HACKHACK #2336: QuantitativeScales don't take min/max of stringy values correctly
        // {
        //   description: "gives the minimum and maxiumum when the domain is stringy",
        //   values: ["11", "3", "2", "1"]
        // },
        {
          description: "ignores NaN, null, and undefined values when computing the extent",
          values: [NaN, null, undefined, expectedMin, expectedMax]
        },
        {
          description: "ignores infinite values when computing the extent",
          values: [Infinity, -Infinity, expectedMin, expectedMax]
        }
      ];

      testCases.forEach((testCase) => {
        it(testCase.description, () => {
          const scale = new Plottable.QuantitativeScale();
          const computedExtent = scale.extentOfValues(testCase.values);
          assert.deepEqual(computedExtent, expectedExtent, "the extent consists of the minimum and the maximum values");
        });
      });
    });

    describe("tick generation", () => {
      it("can set an get a TickGenerator", () => {
        const scale = new Plottable.QuantitativeScale();
        const tickGenerator = (): any[] => [];
        assert.strictEqual(scale.tickGenerator(tickGenerator), scale, "setting the TickGenerator returns the QuantitativeScale");
        assert.strictEqual(scale.tickGenerator(), tickGenerator, "getter mode returns the set TickGenerator");
      });

      it("uses its TickGenerator to create ticks", () => {
        const scale = new Plottable.QuantitativeScale<number>();
        const expectedTicks = [1, 2, 99];
        const tickGenerator = (passedScale: Plottable.QuantitativeScale<any>) => {
          assert.strictEqual(passedScale, scale, "TickGenerator was passed the QuantitativeScale it was attached to");
          return expectedTicks;
        };
        scale.tickGenerator(tickGenerator);
        const generatedTicks = scale.ticks();
        assert.deepEqual(generatedTicks, expectedTicks, "returned ticks generated by the TickGenerator");
      });
    });
  });
});
